# 第二次作业

## 请说出下列最终的执行结果，并解释为什么

```
		var a = []
		for(var i =0;i < 10;i++)
		{
			a[i] = return (function()
			{
				console.log(i)
			}
		}
		a[6]() //10
```

答： 执行结果是 10 . 因为 i 是一个全局变量，当循环执行完后 i = 10 ，所以调用函数打印出的 i 始终都是 10 .

## 请说出下列最终的执行结果，并解释为什么

```
var tmp = 123;

if(true) {
	console.log(tmp) //err
	let tmp
}
```
答： 会报错，因为声明了 let 变量的块级作用域内会形成`暂时性死区`，在该变量声明之前这个变量都是不可用的，并且在块级作用域内的这个变量不会受到外部的影响，所以也无法打印出全局变量。

## 结合ES6新语法，用最简单的方式找出数组的最小值

```
var arr = [12,34,32,89,4]

```
答：
```
var arr = [12,34,32,89,4]
		
console.log(Math.min(...arr)) // 4
```

## 请详细说明var，let，const 三种声明方式之间的具体差别

答：

* var 声明存在变量提升，相当于在作用域顶部声明一个 var = undefined，所以var 可以在声明之前使用。 而 let 和 const 只能在声明之后使用，否则会报错。

* let 和 const 在声明时会形成暂时性死区，在声明语句前该变量都不可用。 而var 则可以使用。

* let 和 const 存在一个`块级作用域`,也就是包裹在一个{ } 内的作用域，在作用域内及其子作用域内可用，在作用域外不可用。 var 只存在`全局作用域`和`函数作用域`。

* var 可以隐式声明，隐式声明的变量都是全局变量。 而 let 和 const无法隐式声明。

* 同一作用域下的 let 和 const 无法声明同名变量，而 var 可以。

* const 一旦声明必须赋值，且不能使用`null`占位，声明后无法修改（复合数据类型可以修改）

## 请说出下列代码最终输出的结果，并解释为什么

```
var a = 10;
var obj = {
	a:20,
	fn(){
		setTimeout(()=>{
			console.log(this.a)
		})
	}
}

obj.fn() // 20

```
因为 setTimeout 内部执行的函数是一个箭头函数，所以其内部的this是定义时所在作用域的 this，即fn()内部的this，而fn被obj所调用，所以这个this 就是 obj的this，而不是全局的 this。

## 简述 symbol 类型的用途

* 避免对象成员名重复

* 因为无法创建完全一样的symbol，可以模拟对象的私有属性

## 说说什么是浅拷贝，什么是深拷贝？

答：

* 浅拷贝： 对于引用数据类型，该对象的名称会存在栈内存中，值会存在堆内存中，栈内存中会存放一个只想堆内存的地址， 浅拷贝就是拷贝了占内存中的内存地址，当通过访问拷贝对象时，访问到的是同一个堆内存中的地址。

* 深拷贝：重新在堆内存中开辟一个内存空间，将被拷贝的值复制一份放入该内存中，同时栈内存中也会有一个新的指针指向该内存地址。 这时两个对象之间完全独立，互不影响。

## 请简述 Typescript 与 JavaScript之间的关系

答： typescript 是 JavaScript的 超集，typescript包含了js的所有语法和概念，同时新增了类型系统，支持ES6+语法。ts文件可以通过编译转化为js文件。任何一个可以开发JavaScript的运行环境都可以用typescript开发。 简而言之，typescript就是一个 弥补了 JavaScript 弱类型和动态类型缺点的语言。

## 请谈谈我所认为的typescript 的优缺点

优点：

* 强类型，在代码编写阶段就能检查出错误，而不是像js需要在运行时，并且ts有着严格的类型规范，会大大减少各种莫名其妙难以调试的bug产生的可能性。

* 能够拥有快速的代码智能提示，强类型可以让系统快速推导出类型，所以能提供更准确的智能提示。 让编码更加有效率，更加准确。

* 利于维护和重构，typescript 编写的代码能够迅速准确地提示错误，这让系统维护工作变得更加高效简洁。

* 让前端开发人员也能拥有类型意识，而不是像以前使用JavaScript那样，没有好的类型规范意识。

* 对于大型项目的开发，类型规范会让庞大的项目开发不再繁琐，同时也更加安全可靠。

缺点:

* 需要编译成js文件，会增加一些开发成本

* 对于一些小型项目，typescript 前期的类型定义会增加开发成本。

## 描述引用计数的工作原理和优缺点

工作原理： 引用计数器会将每一个对象的引用数记录下来，当对象的引用数改变时，引用计数器会立刻修改记录的值，保证记录的值与真实引用数一致。 当某个对象引用数为零时，就立即回收该对象，释放其内存占用。

优点：
 * 及时性，发现引用数为 0后，就立即进行回收。
 
 * 由于回收工作是实时的，所以很难出现内存栈满的情况，最大限度减少程序暂停的抢矿。

缺点：
* 无法解决循环引用

* 时间开销大，由于需要实时监控对象引用数并且修改引用计数器，所以时间开销较大。

## 描述标记整理算法的工作流程

* 找到所有的`可达对象`(可以通过作用域链找到的对象)，给其打上标记

* 将所有打上标记的活动对象整理到一个连续的内存地址

* 在GC工作的时候，会将所有未被打上标记的对象清除，同时将所有打上标记的对象的标记清除

## 描述V8中新生代存储区垃圾回收的流程

答

* 新生代存储区将内存空间一分为二，分别为 使用空间from 和 空闲空间to

* 当活动对象存储至from空间

* 触发GC时，先进行标记整理，将所有from对象中的活动对象拷贝至 to 

* 释放掉from空间，然后将from 与 to 空间交换(from变成 to，to 变成 from)，经历过一次GC的新生代对象会晋升为老生代对象

## 描述增量标记算法在何时使用及工作原理

由于GC操作和程序执行是互斥的，所以为了不让程序在执行垃圾回收时有明显卡顿，使用了增量标记算法来优化。

在对老生代存储空间进行垃圾回收时，由于老生代存储空间较大，存储的数据也多，如果一次性完成遍历对象进行标记的操作，那么程序可能会有明显的停滞。 所以使用增量标记来优化。

工作原理：

* 在进行标记清除算法时，在遍历对象对活动对象进行标记时，先对一部分对象进行标记，比如对全局对象下的活动对象进行标记，然后暂停便利，让程序执行一段时间，然后继续遍历和标记操作，对第二层对象进行标记，然后再暂停让程序执行，如此往复交替执行，直到遍历完成。 



